<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebGL弹幕渲染压力测试</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: white;
    }

    .controls {
      margin-bottom: 20px;
      padding: 20px;
      background-color: #2a2a2a;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .control-group {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    label {
      min-width: 120px;
      font-weight: bold;
    }

    input[type='range'] {
      flex: 1;
      max-width: 300px;
    }

    .value-display {
      min-width: 60px;
      text-align: center;
      background-color: #3a3a3a;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
    }

    .stats {
      display: flex;
      gap: 20px;
      margin-top: 15px;
    }

    .stat {
      background-color: #3a3a3a;
      padding: 10px;
      border-radius: 5px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #4caf50;
    }

    .stat-label {
      font-size: 0.9em;
      color: #ccc;
    }

    canvas {
      border: 2px solid #444;
      border-radius: 10px;
      background-color: #000;
      cursor: crosshair;
    }

    .canvas-container {
      text-align: center;
    }
  </style>
</head>

<body>
  <h1>弹幕渲染压力测试</h1>

  <div class="controls">
    <div class="control-group">
      <label for="bulletCount">弹幕数量:</label>
      <input type="range" id="bulletCount" min="10" max="100000" value="100" step="10" />
      <div class="value-display" id="bulletCountValue">100</div>
    </div>

    <div class="control-group">
      <label for="spawnRate">生成速度:</label>
      <input type="range" id="spawnRate" min="1" max="100000" value="5" step="1" />
      <div class="value-display" id="spawnRateValue">5/秒</div>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="currentBullets">0</div>
        <div class="stat-label">当前弹幕</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="fps">60</div>
        <div class="stat-label">FPS</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="totalSpawned">0</div>
        <div class="stat-label">总生成数</div>
      </div>
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
  </div>

  <script>
    class BulletRenderer {
      constructor() {
        this.canvas = document.getElementById('gameCanvas')
        /** @type {WebGLRenderingContext} */
        this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl')

        if (!this.gl) {
          alert('WebGL不受支持，请使用支持WebGL的浏览器')
          return
        }

        this.bullets = []
        this.bulletImage = new Image()
        this.imageLoaded = false

        // 控制参数
        this.maxBullets = 100
        this.spawnRate = 100
        this.totalSpawned = 0

        // FPS计算
        this.fps = 60
        this.frameCount = 0
        this.lastTime = performance.now()
        this.fpsUpdateTime = 0

        // 中心点（发射源）
        this.centerX = this.canvas.width / 2
        this.centerY = this.canvas.height / 2

        // 子弹精灵信息
        this.bulletSpriteSize = 16
        this.bulletTypes = 16 // 第一排16种子弹

        // WebGL相关属性
        this.shaderProgram = null
        this.vertexBuffer = null
        this.texture = null
        this.projectionMatrix = null

        this.initWebGL()
        this.initEventListeners()
        this.loadBulletImage()
        this.lastSpawnTime = 0
        this.gameLoop()
      }

      initWebGL() {
        // 创建着色器程序
        this.shaderProgram = this.createShaderProgram()
        this.gl.useProgram(this.shaderProgram)

        // 设置WebGL状态
        this.gl.enable(this.gl.BLEND)
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA)
        this.gl.clearColor(0.0, 0.0, 0.067, 1.0) // 深蓝色背景

        // 创建顶点缓冲区
        this.vertexBuffer = this.gl.createBuffer()

        // 创建四边形顶点数据
        const vertices = new Float32Array([
          // 位置 (x, y), 纹理坐标 (u, v)
          -0.5, -0.5, 0.0, 0.0,  // 左下
          0.5, -0.5, 1.0, 0.0,  // 右下
          -0.5, 0.5, 0.0, 1.0,  // 左上
          0.5, -0.5, 1.0, 0.0,  // 右下
          0.5, 0.5, 1.0, 1.0,  // 右上
          -0.5, 0.5, 0.0, 1.0   // 左上
        ])

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW)

        // 创建投影矩阵
        this.projectionMatrix = this.createProjectionMatrix()

        // 设置uniform变量
        const projectionLocation = this.gl.getUniformLocation(this.shaderProgram, 'u_projection')
        this.gl.uniformMatrix4fv(projectionLocation, false, this.projectionMatrix)

        // 获取uniform位置
        this.uniformLocations = {
          translate: this.gl.getUniformLocation(this.shaderProgram, 'u_translate'),
          rotation: this.gl.getUniformLocation(this.shaderProgram, 'u_rotation'),
          scale: this.gl.getUniformLocation(this.shaderProgram, 'u_scale'),
          texIndex: this.gl.getUniformLocation(this.shaderProgram, 'u_texIndex'),
          texture: this.gl.getUniformLocation(this.shaderProgram, 'u_texture'),
          blurAmount: this.gl.getUniformLocation(this.shaderProgram, 'u_blurAmount')
        }

        // 设置顶点属性
        const positionLocation = this.gl.getAttribLocation(this.shaderProgram, 'a_position')
        this.gl.enableVertexAttribArray(positionLocation)
        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0)

        const texCoordLocation = this.gl.getAttribLocation(this.shaderProgram, 'a_texCoord')
        this.gl.enableVertexAttribArray(texCoordLocation)
        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8)
      }

      createShaderProgram() {
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;

            uniform mat4 u_projection;
            uniform vec2 u_translate;
            uniform float u_rotation;
            uniform float u_scale;

            varying vec2 v_texCoord;

            void main() {
              // 旋转和缩放
              float c = cos(u_rotation);
              float s = sin(u_rotation);
              vec2 rotated = vec2(
                a_position.x * c - a_position.y * s,
                a_position.x * s + a_position.y * c
              ) * u_scale;

              // 平移
              vec2 worldPos = rotated + u_translate;

              gl_Position = u_projection * vec4(worldPos, 0.0, 1.0);
              v_texCoord = a_texCoord;
            }
          `

        const fragmentShaderSource = `
            precision mediump float;

            uniform sampler2D u_texture;
            uniform float u_texIndex;
            uniform float u_blurAmount;
            varying vec2 v_texCoord;

            void main() {
              // 计算精灵图中的位置
              float spriteSize = 16.0;
              float textureSize = 256.0;
              float spritesPerRow = textureSize / spriteSize;

              float row = floor(u_texIndex / spritesPerRow);
              float col = mod(u_texIndex, spritesPerRow);

              vec2 spriteOffset = vec2(col, row - 1.0 / 16.0) / (textureSize / spriteSize);
              vec2 spriteScale = vec2(spriteSize / textureSize);

              vec2 finalTexCoord = spriteOffset + v_texCoord * spriteScale;

              // 如果没有blur效果，直接采样
              if (u_blurAmount <= 0.0) {
                gl_FragColor = texture2D(u_texture, finalTexCoord);
              } else {
                // 应用更强的blur效果
                vec4 color = vec4(0.0);
                float blurSize = u_blurAmount / textureSize; // 增加blur范围
                int samples = 9; // 5x5采样

                // 3x3 box blur
                for (int x = -1; x <= 1; x++) {
                  for (int y = -1; y <= 1; y++) {
                    vec2 offset = vec2(float(x), float(y)) * blurSize;
                    color += texture2D(u_texture, finalTexCoord + offset);
                  }
                }

                gl_FragColor = color / float(samples);
              }

              // 丢弃透明像素
              if (gl_FragColor.a < 0.1) {
                discard;
              }
            }
          `

        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource)
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource)

        const program = this.gl.createProgram()
        this.gl.attachShader(program, vertexShader)
        this.gl.attachShader(program, fragmentShader)
        this.gl.linkProgram(program)

        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
          console.error('着色器程序链接失败:', this.gl.getProgramInfoLog(program))
          return null
        }

        return program
      }

      createShader(type, source) {
        const shader = this.gl.createShader(type)
        this.gl.shaderSource(shader, source)
        this.gl.compileShader(shader)

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('着色器编译失败:', this.gl.getShaderInfoLog(shader))
          this.gl.deleteShader(shader)
          return null
        }

        return shader
      }

      createProjectionMatrix() {
        // 正交投影矩阵
        const left = 0
        const right = this.canvas.width
        const bottom = this.canvas.height
        const top = 0
        const near = -1
        const far = 1

        return new Float32Array([
          2 / (right - left), 0, 0, 0,
          0, 2 / (top - bottom), 0, 0,
          0, 0, 2 / (near - far), 0,
          (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1
        ])
      }

      loadBulletImage() {
        this.bulletImage.onload = () => {
          this.createTexture()
          this.imageLoaded = true
          console.log('弹幕精灵图加载完成')
        }
        this.bulletImage.src = 'bullet.png'
      }

      createTexture() {
        this.texture = this.gl.createTexture()
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture)

        // 设置纹理参数
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR)
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR)

        // 上传图像数据
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.bulletImage)
      }

      initEventListeners() {
        const bulletCountSlider = document.getElementById('bulletCount')
        const spawnRateSlider = document.getElementById('spawnRate')

        bulletCountSlider.addEventListener('input', e => {
          this.maxBullets = parseInt(e.target.value)
          document.getElementById('bulletCountValue').textContent =
            this.maxBullets
        })

        spawnRateSlider.addEventListener('input', e => {
          this.spawnRate = parseInt(e.target.value)
          document.getElementById('spawnRateValue').textContent =
            this.spawnRate + '/秒'
        })

        // 点击画布改变发射中心
        this.canvas.addEventListener('click', e => {
          const rect = this.canvas.getBoundingClientRect()
          this.centerX = e.clientX - rect.left
          this.centerY = e.clientY - rect.top
        })
      }

      createBullet() {
        if (this.bullets.length >= this.maxBullets) return

        // 随机方向（0-360度）
        const angle = Math.random() * Math.PI * 2

        // 随机初速度
        const speed = 0.01 + Math.random() * 0.1

        // 随机子弹类型（第一排16种）
        const bulletType = Math.floor(Math.random() * this.bulletTypes * 11)

        const bullet = {
          x: this.centerX,
          y: this.centerY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          type: bulletType,
          rotation: angle, // 旋转角度
          spawnFrame: 0, // 生成后的帧数
          maxBlurFrames: 60, // 最大blur帧数
          initialBlur: 1.0, // 初始blur强度
        }

        this.bullets.push(bullet)
        this.totalSpawned++
      }

      updateBullets() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
          const bullet = this.bullets[i]

          // 更新位置
          bullet.x += bullet.vx
          bullet.y += bullet.vy

          // bullet.vy += 0.001

          bullet.rotation = Math.atan2(bullet.vy, bullet.vx)

          // 更新生成帧数
          bullet.spawnFrame++

          // 检查边界，如果超出屏幕则移除
          if (
            bullet.x < -20 ||
            bullet.x > this.canvas.width + 20 ||
            bullet.y < -20 ||
            bullet.y > this.canvas.height + 20
          ) {
            this.bullets.splice(i, 1)
          }
        }
      }

      renderBullets() {
        if (!this.imageLoaded || this.bullets.length === 0) return

        // 绑定纹理
        this.gl.activeTexture(this.gl.TEXTURE0)
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture)
        this.gl.uniform1i(this.uniformLocations.texture, 0)

        // 绑定顶点缓冲区
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)

        // 为每个弹幕绘制
        this.bullets.forEach(bullet => {
          // 计算当前blur强度
          let blurAmount = 0.0
          let scaleMultiplier = 1.0
          if (bullet.spawnFrame <= bullet.maxBlurFrames) {
            // 在前10帧内，blur从初始值线性减少到0
            const progress = bullet.spawnFrame / bullet.maxBlurFrames
            blurAmount = bullet.initialBlur * (1.0 - progress)
            // 有blur时子弹变大，最大1.5倍
            scaleMultiplier = 1.0 + (blurAmount / bullet.initialBlur) * 0.5
          }

          // 设置位置
          this.gl.uniform2f(this.uniformLocations.translate, bullet.x, bullet.y)

          // 设置旋转
          this.gl.uniform1f(this.uniformLocations.rotation, Math.PI / 2 + bullet.rotation)

          // 设置缩放 - 根据blur强度调整大小
          this.gl.uniform1f(this.uniformLocations.scale, this.bulletSpriteSize * scaleMultiplier)

          // 设置纹理索引
          this.gl.uniform1f(this.uniformLocations.texIndex, bullet.type)

          // 设置blur强度
          this.gl.uniform1f(this.uniformLocations.blurAmount, blurAmount)

          // 绘制
          this.gl.drawArrays(this.gl.TRIANGLES, 0, 6)
        })
      }

      renderCenter() {
        // 由于WebGL渲染线条比较复杂，这里简化处理
        // 可以通过添加一个简单的十字形精灵来实现
      }

      updateStats() {
        document.getElementById('currentBullets').textContent =
          this.bullets.length
        document.getElementById('totalSpawned').textContent =
          this.totalSpawned
        document.getElementById('fps').textContent = Math.round(this.fps)
      }

      calculateFPS(currentTime) {
        this.frameCount++

        if (currentTime - this.fpsUpdateTime >= 1000) {
          this.fps = this.frameCount
          this.frameCount = 0
          this.fpsUpdateTime = currentTime
        }
      }

      gameLoop() {
        const currentTime = performance.now()
        const deltaTime = currentTime - this.lastTime
        this.lastTime = currentTime

        // 计算FPS
        this.calculateFPS(currentTime)

        // 生成新子弹
        const spawnInterval = 1000 / this.spawnRate // 毫秒
        if (currentTime - this.lastSpawnTime >= spawnInterval) {
          for (let i = 0; i < 100; i++) this.createBullet()

          this.lastSpawnTime = currentTime
        }

        // 更新游戏逻辑
        this.updateBullets()

        // 清空画布
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height)
        this.gl.clear(this.gl.COLOR_BUFFER_BIT)

        // 渲染
        this.renderBullets()
        this.renderCenter()

        // 更新统计信息
        this.updateStats()

        requestAnimationFrame(() => this.gameLoop())
      }
    }

    // 等待页面加载完成后启动
    window.addEventListener('load', () => {
      new BulletRenderer()
    })
  </script>
</body>

</html>